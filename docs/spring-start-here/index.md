# 스프링 교과서

## 2. 스프링 컨텍스트: 빈 정의

- 스프링 컨텍스트(ApplicationContext)는 애플리케이션에 사용할 객체(Bean)를 생성하고 관리하는 핵심 컨테이너다.
- 스프링 컨텍스트에 등록하지 않은 객체는 스프링이 관리하지 않는다.
    - 의존성 주입(Dependency Injection), 생명주기 관리 등 스프링의 지원을 받으려면 반드시 등록해야 한다.
- 스프링 컨텍스트에 등록한 객체를 스프링 빈(Spring Bean)이라고 한다.

### 스프링 빈 등록 방법

- 스프링 빈을 추가하는 방법은 크게 3가지다.

**@Bean을 사용한 수동 등록**

- 구성(`@Configuration`)클래스를 정의하고 개발자가 직접 Bean을 정의한다.
    - XML 기반 설정도 가능하지만, 최근 구성 클래스는 Java 기반(Java-based configuration)을 주로 사용한다.
- 외부 라이브러리, 제 3자 코드 등 개발자가 직접 어노테이션을 추가할 수 없는 클래스를 Bean으로 등록할 때 유용하다.

**스트레오타입 어노테이션(Stereotype Annotation)을 사용한 자동 등록**

- 클래스에 `@Component`계열 어노테이션을 추가하고 `@ComponentScan`으로 탐색 경로를 지정한다.
    - `@Component`
    - `@Controller`, `@Service`, `@Repository`등이 해당된다.
- Spring Boot 환경에서는 별도 설정 없이도 `@SpringBootApplication` 내부에 포함된 `@ComponentScan` 덕분에 자동으로 빈 탐색이 이뤄진다.

**프로그래밍 방식(Programmatic Registration)**

- `registerBean()` 메서드를 사용하면 컨텍스트에 Bean을 추가하는 로직을 재정의하여 구현할 수 있다.
- 실무에서 자주 사용하지 않는다.

## 3. 스프링 컨텍스트: 빈 작성

- 애플리케이션의 대부분 기능은 단일 객체가 모든 작업을 처리하지 않고, 여러 객체의 협력으로 이뤄진다.
- 객체가 자신의 책임을 수행하려면 종종 다른 객체에게 작업을 위임하고, 자연스럽게 의존 관계(Dependency)가 발생한다.
- 스프링은 의존 관계를 직접 생성(`new`)하지 않고 스프링 컨테이너(ApplicationContext)가 대신 관리하도록 지원한다.

### 스프링 빈 의존 관계 설정하기

- 빈을 생성하는 메서드에서 다른 빈을 생성하는 `@Bean` 메서드를 직접 참조
- 매개변수 타입의 빈을 컨텍스트에서 검색하고 해당 빈을 매개변수 값으로 전달
- `@Autowired`

**@Autowired**

- 필드 주입: 테스트 코드, 개념 증명(PoC)에 주로 사용
- 생성자 주입: 실제 코드에 가장 많이 사용
- setter: 프로덕션 수준의 코드에서는 자주 사용하지 않음

### 순환 의존성

> A가 B를 필요로 하고, B는 다시 A를 필요로 한다.

- 순환 의존성이 있는 빈은 생성할 수 없고, 예외를 발생시키며 실행은 실패한다.
- 빈을 구성할 때 순환 의존은 반드시 피해야 한다.

### 동일한 타입의 빈을 주입할 때

- `@Primary`를 사용하면 동일한 타입의 빈 중 기본으로 사용할 빈을 지정한다.
- `@Qualifier`를 사용하면 빈 이름을 지정하고 이름으로 주입한다.

## 4. 스프링 컨텍스트: 추상화

### 인터페이스 도입

**직접 결합의 문제**

```java
public class UserService {
    private MySqlRepository repository = new MySqlRepository();

    public void addUser(User user) {
        repository.save(user);
    }
}
```

- 직접 결합은 객체가 다른 객체의 구체적인 클래스를 직접 참조하고 생성하여 사용하는 행동을 의미한다.
- 클래스의 내부 구현이 변경되면 직접 사용하는 모든 클래스도 수정해야 한다.
    - 변경에 취약하며 유지보수를 어렵게 만든다.
- 실제 구현 객체에 강하게 의존하기 때문에 테스트가 어렵다.

**인터페이스 도입**

```java
public interface UserRepository {
    void save(User user);
}

public class MySqlRepository implements UserRepository {

}

public class UserService {
    private UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public void addUser(User user) {
        repository.save(user);
    }
}
```

- 두 객체 사이에 인터페이스를 두어 다른 객체의 구체적인 구현이 아닌 역할에만 의존하도록 한다.
- 의존 역전 원칙(DIP, Dependency Inversion Principle)은 결합도를 낮추고 유연성을 극대화하는 핵심 원칙이다.

### POJO(Plain Old Java Object)

- POJO는 특정 기술이나 프레임워크에 종속되지 않는 단순 객체를 의미한다.
- 외부에 종속적인 라이브러리나 기술을 상속하거나 직접적으로 구현하지 않는다.
- 일반적으로 속성(fields)과 메서드(methods)(Getter/Setter, 비즈니스 로직)만 포함한다.

### 스트레오타입 어노테이션 사용 위치

- 스프링이 관리하는 Bean은 실제로 동작하는 객체(인스턴스)여야 한다.
- 인터페이스에 어노테이션을 사용해도 스프링 컨테이너가 관리할 수 있는 구체적인 인스턴스가 생성되지 않는다. 따라서 구체적인 구현 클래스에 어노테이션을 사용한다.

### DI(Dependency Injection)

- DI는 객체 간 의존 관계를 객체 자신이 아닌 외부(스프링 컨테이너)에서 주입하는 디자인 패턴이다.
- DI는 객체 지향 설계의 핵심 목표인 느슨한 결합(Loose Coupling)과 높은 응집도(High Cohesion)를 달성하도록 지원한다.
- 스프링은 개발의 복잡성을 낮추기 위해 DI를 핵심 원리로 채택했다.

### 구체적인 스트레오타입 어노테이션 사용

- `@Component`는 가장 기본적인 Bean 등록 어노테이션이다. 스프링은 세분화한 구체적인 어노테이션을 제공한다.
- **구체적인 어노테이션**
    - 명확한 역할 부여 및 가독성
    - 특화된 기능 제공
    - 선택적 스캔 및 AOP 적용의 용이함

## 5. 스프링 컨텍스트: 빈의 스코프 및 수명 주기

- 스프링 컨텍스트는 빈(Bean) 스코프를 통해 객체 인스턴스를 관리하는 방법을 정의한다. 
    - 주요 스코프는 싱글톤(Singleton)과 프로토타입(Prototype)이다.

### 빈 스코프(Bean Scopes)

**싱글톤(Singleton)**

- 스프링의 기본 스코프, 스프링 컨텍스트 내에서 하나의 유일한 객체 인스턴스만 생성하고 관리한다.
- 컨텍스트 내에서 빈 이름을 사용하여 참조하는 모든 위치에서 동일한 인스턴스를 얻는다.
- 여러 스레드가 동일한 인스턴스에 접근하기 때문에, 불변(immutable)하게 만들기를 권장한다.
    - 주로 생성자 주입을 통해 만든다.
- 변경 가능한 속성이 필요할 때, 개발자가 직접 스레드 동기화를 처리해야 경쟁 상태(Race Condition)를 방지할 수 있다.
- 스프링 싱글톤은 스프링 컨테이너 내에서만 싱글톤임을 보장한다.

**프로토타입(Prototype)**

- 빈을 참조할 때마다 해당 타입의 새로운 객체 인스턴스를 생성하는 스코프다.
- 스프링은 객체 타입에만 집중하고, 요청이 들어올 때마다 새로운 인스턴스를 만든다.
- 주로 변경 가능하고, 각 사용 시점마다 고유한 인스턴스가 필요한 경우에만 사용한다.
- 프로토타입 빈을 싱글톤 빈에 주입할 경우, 싱글톤 빈이 생성되는 시점에 단 한 번만 프로토타입 인스턴스가 생성되어 주입된다. 이후 싱글톤 빈을 사용할 때마다 새로운 프로토타입 인스턴스를 얻지 못한다.

### 빈 인스턴스 생성 시점

**즉시 인스턴스 생성(Eager Initialization)**

- 스프링의 기본 동작 방식, 스프링 컨텍스트가 만들어질 때 즉시 빈 인스턴스를 생성한다.

**지연 인스턴스 생성(Lazy Initialization)**

- 빈이 실제로 참조되는 시점에 인스턴스를 생성한다.
- 성능 최적화를 위해 사용할 수 있지만, 애플리케이션 설계의 잠재적 문제가 있다는 신호일 수 있다.
    - 근본적인 원인을 해결되지 않고 `@Lazy`를 사용하여 문제가 덮어지는 상황을 의미

## 6. 스프링 AOP로 애스펙트 사용

### 애스펙트(관점) 지향 프로그래밍(AOP, Aspect-Oriented Programming)

- 애스펙트(Aspect)는 프레임워크가 메서드의 호출을 가로채고 실행을 변경할 수 있는 방법이다.
- 애스펙트는 비즈니스로직과 횡단 관심사(Cross-cutting Concerns)를 분리하여 개발자가 기능 구현에 집중할 수 있도록 돕는다.
    - 반복적으로 사용하는 공통 기능(횡단 관심사)을 처리한다. (트랜잭션, 로깅)
    - 로깅 방식, 보안 정책을 변경할 때 처리가 쉽다.
- AOP는 프록시(Proxy) 패턴을 사용한다.
    - 빈이 애스펙트의 PointCut 대상이라면 실제 객체 대신 프록시 객체를 동적으로 생성한다.
    - 클라이언트는 실제 객체가 아닌 프록시 객체의 참조를 받는다.
    - 클라이언트가 서비스 메서드를 호출하면 프록시 객체가 먼저 가로챈다.
    - 프록시는 가로챈 호출 전후로 애스펙트에 정의된 Advice 코드(로깅, 트랜잭션)를 실행한다.
    - Advice 실행을 완료 후, 프록시는 실제 대상 객체로 위임하여 비즈니스로직을 실행한다.

**핵심 용어**

- Aspect: `@Aspect`, 관심사를 정의한 클래스, 횡단 관심사를 모듈화 한 단위
- Join Point: Advice를 적용할 수 있는 지점(메서드 실행, 필드 접근, 예외 처리 등), Advice가 실행되는 실제 위치
- Advice: 특정 조인 포인트에서 실행되어야 할 코드(`@Around`, `@Before`, `@After`), 무엇을 할지 정의
- Pointcut: Advice를 적용할 Join Point의 규칙/집합, 어디에 적용할지(특정 패키지의 모든 메서드)

**사용법**

```kotlin
// AOP(Aspect-Oriented Programming)
implementation("org.springframework.boot:spring-boot-starter-aop")
```

- 스프링에서 AOP를 사용하려면 의존성을 추가해야 한다.

**위험성**

- 애스펙트는 강력하지만, 오용될 경우 코드의 복잡성을 증가시키고 디버깅을 어렵게 만든다.
- AOP는 코드가 명시적으로 호출되지 않아도 실행된다. 애플리케이션의 실제 동작 흐름을 추적하기 어렵게 만든다.
- 잘못된 범위 설정은 의도치 않은 메서드를 가로채거나 성능 저하가 발생할 수 있다.

**실제 사례**

- `@Transactional`: 메서드 호출 전후에 트랜잭션 시작, 커밋, 롤백 로직을 자동으로 주입한다.
- `@PreAuthorize`,` @PostAuthorize`: 스프링 시큐리티에 사용한다. 메서드 실행 전후에 권한 검사 로직을 삽입하여 접근을 제어한다.

**참고 자료**

- [@AspectJ support](https://docs.spring.io/spring-framework/reference/core/aop/ataspectj.html)

### 로깅을 사용하는 이유

- 애플리케이션 운영 환경에서 발생할 수 있는 복잡한 문제를 체계적으로 관리하고 분석할 수 있게 지원한다.
- `System.out`은 메시지를 단순히 출력할 뿐, 메시지의 중요도를 구분할 수 없다. 반면, 로깅 프레임워크는 메시지에 레벨(Level)을 부여하여 정보의 중요도를 분류하고 관리할 수 있다.
- 로깅 메시지에 표준화된 형식을 적용하여 가독성을 높이고 분석을 용이하게 한다.
- 로깅 프레임워크는 성능 최적화가 되어 있다.

### 사용자 정의 어노테이션

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ToLog {
}
```

- `@Retention`: 자바가 실행 중 어노테이션 정보를 읽고 특정 로직을 수행하거나 AOP처럼 기능을 가로채려면, 리플렉션을 사용할 수 있도록 `RUNTIME`으로 설정해야 한다.
- `@Target`: 어노테이션을 클래스, 메서드, 필드 등 어떤 요소(Element)에 붙일 수 있는지 대상을 지정한다.

## 7. 스프링 부트와 스프링 MVC 이해

### 웹 애플리케이션의 특징과 구현 방식

- 웹 애플리케이션은 여러 사용자가 동시에 접속하여 요청을 보낼 수 있다. 서블릿 컨테이너는 각 요청마다 별도의 스레드를 할당하여 동시성을 처리하고 안정성을 확보한다.
- **구현 방식**
    - **서버사이드 렌더링(SSR)**: 서버가 클라이언트 요청에 응답하는 완성된 HTML 뷰를 제공(JSP, Thymeleaf, Freemaker)
    - **프론트엔드-백엔드 분리**(API 방식): 서버는 JSON, XML 등의 데이터 형식을 전송하고 클라이언트가 데이터를 받아 화면을 렌더링(RESTful API 구현)

### 서블릿 컨테이너(Servlet Container)

- 서블릿 컨테이너는 클라이언트의 HTTP 요청과 응답을 자바 객체(`HttpServletRequest`, `HttpServletResponse`)로 변환하고 관리하는 표준 규약이다.
- 톰캣(Tomcat)은 서블릿 컨테이너 규약을 실제로 구현한 WAS(Web Application Server)중 하나다.
- 서블릿은 웹 애플리케이션 로직의 최초 진입점이다. 컨테이너에 의해 생명주기(생성, 서비스, 소멸)를 관리한다.
- 스프링은 개발자가 직접 서블릿을 정의하고 등록하는 대신 빈 관리를 활용하여 서블릿 객체를 서블릿 컨테이너에 등록한다.

### 디스패처 서블릿(Dispatcher Servlet)과 Spring MVC

- 디스패처 서블릿은 프론트 컨트롤러 패턴을 구현한 Spring MVC 핵심 구성요소다.
- **프론트 컨트롤러(Front Controller)**
    - 단일 진입점: 모든 클라이언트 요청을 받는 유일한 서블릿이다. 기존 서블릿 방식처럼 요청마다 서블릿을 만들 필요 없이, 모든 요청을 디스패처 서블릿이 먼저 받아 처리한다.
    - 디스패처 서블릿은 요청을 받고, 처리 로직을 담당하는 여러 핸들러(Controller)에게 작업을 위임한다.

**디스패처 서블릿의 요청 처리 과정**

1. 요청 수신: 서블릿 컨테이너(톰캣)에게 `HttpServletRequest`를 받는다.
2. 핸들러 매핑(Handler Mapping): 요청 URI를 분석하고 요청을 실제로 처리할 컨트롤러를 찾는다.
3. 핸들러 실행: 컨트롤러를 실행한다. 비즈니스 로직을 수행하고 Model과 View 이름을 반환한다.
4. 뷰 리졸버(View Resolver): 컨트롤러가 반환한 View 이름을 기반으로 실제 뷰 템플릿을 View 객체로 변환한다.
5. 뷰 렌더링: Model 데이터를 사용하여 최종 HTML 응답 본문을 생성한다.
6. 응답 전송: 디스패처 서블릿이 최종 응답을 `HttpServletResponse`에 담아 서블릿 컨테이너를 통해 클라이언트로 전송한다.

### 스프링 부트(Spring Boot)

- 스프링 부트는 스프링을 기반으로 실무 환경에 사용 가능한 독립 실행형 애플리케이션을 복잡한 고민 없이 작성할 수 있도록 돕는 스프링 프로젝트다.
- **핵심 기능**
  - 의존성 관리(Dependency Management): spring-boot-starter 사용
  - 배포(Deployment) 간소화: 실행 가능한 `jar` 안에 WAS가 포함되어 있어 `jar` 실행으로 간편하게 배포 가능
  - 자동 설정(Auto Configuration): 구성보다 관례(COC, Convention Over Configuration) 원칙을 적용하여 필요한 기능에 대한 기본 구성을 제공
